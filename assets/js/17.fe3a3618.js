(window.webpackJsonp=window.webpackJsonp||[]).push([[17],{334:function(t,r,a){"use strict";a.r(r);var s=a(7),e=Object(s.a)({},(function(){var t=this,r=t._self._c;return r("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[r("h2",{attrs:{id:"踩的坑"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#踩的坑"}},[t._v("#")]),t._v(" 踩的坑")]),t._v(" "),r("p",[t._v("之前在做实验的时候，发现网络训练不动，经过调试发现输入的数据在过了一层全局平均池化之后都变为了接近0的值，起初以为是平均池化的锅，找了半天没找到问题所在。")]),t._v(" "),r("p",[t._v("后来仔细检查网络结构时发现，我在使用全局平均池化前有一个Transformer的编码器层，无意之间又看了看，发现最后的输出要做一个layernorm，猛然惊醒，layernorm\n会将一个特征里的数据转换为均值为0，方差为1的形式，均值为0。。。。。。。。这不就是为什么后面的全局平均池化计算结果为0的原因吗，困扰了许久的bug终于解决了。。。。")]),t._v(" "),r("h2",{attrs:{id:"吸取的教训"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#吸取的教训"}},[t._v("#")]),t._v(" 吸取的教训")]),t._v(" "),r("p",[t._v("以后在使用全局平均池化之前一定要注意是不是使用了归一化操作，仔细检查归一化作用的维度以及平均池化作用的维度是否一致！！！")])])}),[],!1,null,null,null);r.default=e.exports}}]);